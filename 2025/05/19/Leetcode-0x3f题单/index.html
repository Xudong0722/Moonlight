<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Leetcode-0x3f题单 |  MoonLight</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Leetcode-0x3f题单"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Leetcode-0x3f题单
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/05/19/Leetcode-0x3f%E9%A2%98%E5%8D%95/" class="article-date">
  <time datetime="2025-05-19T15:05:13.000Z" itemprop="datePublished">2025-05-19</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">8.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">37 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><p>如何科学刷题？<a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/RvFUtj/">https://leetcode.cn/circle/discuss/RvFUtj/</a></p>
<p>目标：掌握基础算法，每一类型至少做10题左右，循序渐进。</p>
<h1 id="a-定长滑动窗口"><a href="#a-定长滑动窗口" class="headerlink" title="a.定长滑动窗口"></a>a.定长滑动窗口</h1><p>这类题往往是求某个固定长度内满足某种条件的最大值、最小值，一般处理思路是：</p>
<ul>
<li>向窗口中累加元素</li>
<li>如果窗口长度已经到达固定长度，更新答案</li>
<li>移出窗口最左边的元素，继续往后走</li>
</ul>
<h3 id="最少交换次数来组合所有的-1-II"><a href="#最少交换次数来组合所有的-1-II" class="headerlink" title="最少交换次数来组合所有的 1 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/description/">最少交换次数来组合所有的 1 II</a></h3><p><strong>怎么提炼出定长窗口？</strong></p>
<p>因为我们可以交换任意两个不同位置的值，所以一定可以把所有的1聚合在一起，那么1的个数就是窗口的长度，滑动时，我们看窗口内缺多少个1，就需要交换多少次。</p>
<p><strong>怎么处理环形？</strong></p>
<p>在原数组后面再加上一次原数组，这样窗口往后滑动的时候，就可以连上前面的元素，模拟环形。</p>
<h3 id="滑动子数组的美丽值"><a href="#滑动子数组的美丽值" class="headerlink" title="滑动子数组的美丽值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-subarray-beauty/description/">滑动子数组的美丽值</a></h3><p>这道题有明显的暗示，求出每个长度为k的子数组…</p>
<p><strong>怎么求第x小？</strong></p>
<p>观察数组元素的数据范围，发现范围很小，那么我们就可以用一个数组去记录每个元素出现的次数即可，这样每次从最小的元素开始遍历，就可以找到第x小。</p>
<p><strong>思考：如果数组元素范围很大怎么办？</strong></p>
<h3 id="子串的最大出现次数"><a href="#子串的最大出现次数" class="headerlink" title="子串的最大出现次数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/description/">子串的最大出现次数</a></h3><p>这道题有一个迷惑的地方，就是不需要关注maxsize，因为既然minsize已经满足条件的话，为什么还需要再往后加呢，满足maxsize的话一定满足minsize，所以窗口的长度固定为minisize！</p>
<h3 id="可获得的最大点数"><a href="#可获得的最大点数" class="headerlink" title="可获得的最大点数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/">可获得的最大点数</a></h3><blockquote>
<p><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">几张卡牌</font><strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font>****<font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">排成一行</font></strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，每张卡牌都有一个对应的点数。点数由整数数组</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;cardPoints&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给出。</font></p>
<p><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;k&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">张卡牌。</font></p>
<p><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">你的点数就是你拿到手中的所有卡牌的点数之和。</font></p>
<p><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给你一个整数数组 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;cardPoints&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 和整数 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;k&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，请你返回可以获得的最大点数。</font></p>
</blockquote>
<p><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">关键词： 排成一行，正好拿k张</font></p>
<p>1.按照题意模拟来做，前面拿m张，后面就是拿k-m张，使用前缀和和后缀和来计算答案</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<p>2.定长滑动窗口，窗口大小为n-k，剩下的数量就是k，滑一遍，一边滑一边更新答案即可。</p>
<p>时间复杂度: O(n)</p>
<p>空间复杂度： O(1)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cardPoints, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = cardPoints.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans&#123;INT_MAX&#125;, left&#123;<span class="number">0</span>&#125;, <span class="built_in">len</span>(n-k), tmp&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(cardPoints.<span class="built_in">begin</span>(), cardPoints.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right)&#123;</span><br><span class="line">        tmp += cardPoints[right];</span><br><span class="line">        <span class="keyword">if</span>(right - left + <span class="number">1</span> &lt; len) <span class="keyword">continue</span>;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, tmp);</span><br><span class="line">        tmp -= cardPoints[left++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="b-不定长滑动窗口"><a href="#b-不定长滑动窗口" class="headerlink" title="b.不定长滑动窗口"></a>b.不定长滑动窗口</h1><p>和定长滑动窗口的区别是，我们不限制窗口大小，大概思路是，开始之后就一直找，直到不满足窗口的条件，然后剔除最左边的元素，继续向后扩展。</p>
<p>01月12日update: 上面说的开始之后就一直找，直到不满足窗口的条件。 这里不太准确，可能分成很多种情况:</p>
<ul>
<li>答案可能是我们维护的窗口大小，所以我们要时刻保证窗口是满足条件，所以一旦窗口不满足条件后，我们要一直移除left的元素，然后循环外更新答案（如，<strong>最大连续1的个数，最高频元素的频数，</strong>）</li>
<li>答案是把我们的窗口排除掉所剩下的元素所构成的集合，我们是时刻保证窗口外是满足条件的，这其实与1是相同的，很多时候考虑题目使用逆向思维（如，<strong>每种字符至少取k个，替换子串获得平衡字符串</strong></li>
<li>）</li>
</ul>
<h3 id="最大连续1的个数-III"><a href="#最大连续1的个数-III" class="headerlink" title="最大连续1的个数 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-consecutive-ones-iii/description/">最大连续1的个数 III</a></h3><p>最大可以翻转k个0变成1，也就是说我们可以容忍窗口中最多含有k个0，所以在扩展窗口时考虑这一点即可，剔除左边元素时，如果是0，那么一定用了翻转次数，记得复原。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> zero&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> right  = <span class="number">0</span>; right &lt; n; ++right)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] == <span class="number">0</span>) ++zero;  <span class="comment">//加入窗口</span></span><br><span class="line">    <span class="keyword">while</span>(zero &gt; k)&#123;              <span class="comment">//不满足条件，一直增加left</span></span><br><span class="line">        <span class="keyword">if</span>(nums[left++] == <span class="number">0</span>)&#123;</span><br><span class="line">            --zero;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>); <span class="comment">//更新答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最高频元素的频数"><a href="#最高频元素的频数" class="headerlink" title="最高频元素的频数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/frequency-of-the-most-frequent-element/description/">最高频元素的频数</a></h3><p>和最大连续1的个数类似，那一题是将0变成1，固定消耗是1，但是这一题是将最大消耗是k，让某个数出现的频率最高， 我们定义的窗口是所有的数字都是最后一个数(不够的数字用k来补充)，找到最大的窗口就是答案。</p>
<ul>
<li>代码中用last标记最后一个满足条件的窗口的最后一个元素，因为退出循环时right下标不一定符合条件</li>
<li>sum的维护需要注意，如果不满足记得减去nums[right]</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(right &lt; n)&#123;</span><br><span class="line">               sum += nums[right];</span><br><span class="line">               <span class="type">long</span> <span class="type">long</span> count = <span class="number">1LL</span> * (right - left + <span class="number">1</span>) * nums[right] - sum;</span><br><span class="line">               <span class="keyword">if</span>(count &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(k &gt;= count)&#123;</span><br><span class="line">                       k -= count;</span><br><span class="line">                       sum += count;</span><br><span class="line">                       last = nums[right];</span><br><span class="line">                       ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>);</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       sum -= nums[right];    <span class="comment">//不满足的right记得去掉</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               right ++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(right == n) <span class="keyword">break</span>;</span><br><span class="line">           sum -= last;               <span class="comment">//去掉包含的left，注意他已经变成last了</span></span><br><span class="line">           k += last - nums[left++];  <span class="comment">//收回消耗的k</span></span><br></pre></td></tr></table></figure>

<p>下面有一种更简洁的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> sum&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">begin</span>(nums), <span class="built_in">end</span>(nums));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right)&#123;</span><br><span class="line">    sum += nums[right];</span><br><span class="line">    <span class="keyword">while</span>(k &lt; (<span class="number">1LL</span> * (right - left + <span class="number">1</span>) * nums[right] - sum))&#123;</span><br><span class="line">        sum -= nums[left++];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>

<h3 id="每种字符至少取-K-个"><a href="#每种字符至少取-K-个" class="headerlink" title="每种字符至少取 K 个"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/description/">每种字符至少取 K 个</a></h3><p><strong>解法一:分类讨论</strong></p>
<p>答案存在三种可能：</p>
<ul>
<li>只拿左边的</li>
<li>只拿右边的</li>
<li>两边都取</li>
</ul>
<p>前两种是一样的，只用把字符串翻转一下就可以了。</p>
<p>第三种情况可以使用受限制的滑动窗口，为什么说是受限制的呢，因为我们不能一味地向后滑动，这样会将某个元素使用两次，所以right的移动要考虑left。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">1</span>, right = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; n <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt;= n + left &amp;&amp; (cnt[<span class="number">0</span>] &lt; k || cnt[<span class="number">1</span>] &lt; k || cnt[<span class="number">2</span>] &lt; k))&#123;</span><br><span class="line">        cnt[ss[right++]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt[<span class="number">0</span>]&gt;=k &amp;&amp; cnt[<span class="number">1</span>] &gt;= k &amp;&amp; cnt[<span class="number">2</span>] &gt;= k)&#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[ss[left++]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二:逆向思维</strong></p>
<p>我们只考虑滑动窗口，窗口内的元素是我们不取的，剩下的元素是取走的，那么我们保证这个窗口最大，且剩下的元素能够满足条件即可！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">takeCharacters</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">3</span>]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s)&#123;</span><br><span class="line">            cnt[c -<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">0</span>] &lt; k || cnt[<span class="number">1</span>] &lt; k || cnt[<span class="number">2</span>] &lt; k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans&#123;<span class="number">0</span>&#125;, left&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right)&#123;</span><br><span class="line">            cnt[s[right]-<span class="string">&#x27;a&#x27;</span>] --;  <span class="comment">//拿走当前的元素</span></span><br><span class="line">            <span class="keyword">while</span>(cnt[s[right]-<span class="string">&#x27;a&#x27;</span>] &lt; k)&#123; <span class="comment">//因为上面只拿走了当前的元素，仅可能当前这个元素不满足条件，我们尝试从还回去前面的left</span></span><br><span class="line">                cnt[s[left++]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>);   <span class="comment">//找到最大的窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n-ans;  <span class="comment">//剩下的就是我们必须要取走的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h3 id="毯子覆盖的最多白色砖块数"><a href="#毯子覆盖的最多白色砖块数" class="headerlink" title="毯子覆盖的最多白色砖块数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/description/">毯子覆盖的最多白色砖块数</a></h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-431/problems/maximum-coins-from-k-consecutive-bags/description/">收集连续 K 个袋子可以获得的最多硬币数量</a>的简易版本，相当于权重全为1。</p>
<p>这题我们如何转移到滑动窗口上来呢，因为毯子的长度固定，所以无非是选取毯子的左端点或者右端点，一旦某一个端点固定，另一个也随之确定，所以我们考虑固定某一个端点。这道题考虑左端点和右端点是等价的，这里以右端点举例：</p>
<p>右端点只有可能在两个位置：1.区间上 2.空白处</p>
<p>对于第二种情况：可以看下图，有两种情况，我们将右端点向左移动，只会变得更好或者答案不变</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/43120613/1736075730091-48b25288-a4fc-4c9b-bcdc-bd8af12007dc.png"></p>
<p>对于第一种情况：可以看到，向右移动右端点不会让答案变得更差，①答案更好，②答案不变</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/43120613/1736075947094-1aabaf5b-d1ef-4574-ab66-bd3b7a273459.png"></p>
<p>所以针对以上讨论，我们可以将右端点固定在某个区间的右端点上，这样得到的答案肯定是最优的。</p>
<p><strong>如何运用滑动窗口处理呢？</strong></p>
<p>按左端点对所有区间排序，我们挨个添加当前的区间，因为右端点固定，我们可以计算出左端点，那么之前包括的区间还满足条件么，我们去掉不满足条件的点即可，一个特殊情况是左端点落在某个区间内部，我们只要减掉这个区间内我们没有覆盖到的点即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumWhiteTiles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; tiles, <span class="type">int</span> carpetLen)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        ranges::<span class="built_in">sort</span>(tiles, &#123;&#125;, [](<span class="type">const</span> <span class="keyword">auto</span>&amp; it) &#123; <span class="keyword">return</span> it[<span class="number">0</span>];&#125;);  <span class="comment">//cpp20:https://en.cppreference.com/w/cpp/algorithm/ranges/sort</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left&#123;<span class="number">0</span>&#125;, cover&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> n = tiles.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right)&#123;</span><br><span class="line">            <span class="type">int</span> l = tiles[right][<span class="number">0</span>], r = tiles[right][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//更新区间</span></span><br><span class="line">            cover += (r-l<span class="number">+1</span>);   </span><br><span class="line">            <span class="comment">//更新左端点</span></span><br><span class="line">            <span class="keyword">while</span>(r - carpetLen + <span class="number">1</span> &gt; tiles[left][<span class="number">1</span>])&#123;</span><br><span class="line">                cover -= (tiles[left][<span class="number">1</span>] - tiles[left][<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新答案</span></span><br><span class="line">            <span class="type">int</span> uncover = <span class="built_in">max</span>(<span class="number">0</span>, tiles[right][<span class="number">1</span>] - carpetLen + <span class="number">1</span> - tiles[left][<span class="number">0</span>]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cover - uncover);</span><br><span class="line">            <span class="comment">//std::cout &lt;&lt; left &lt;&lt;&quot; &quot; &lt;&lt; right &lt;&lt; &quot; &quot; &lt;&lt; cover &lt;&lt;&quot; &quot; &lt;&lt; uncover &lt;&lt; &quot; &quot; &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; std::endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="收集连续-K-个袋子可以获得的最多硬币数量"><a href="#收集连续-K-个袋子可以获得的最多硬币数量" class="headerlink" title="收集连续 K 个袋子可以获得的最多硬币数量"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-431/problems/maximum-coins-from-k-consecutive-bags/description/">收集连续 K 个袋子可以获得的最多硬币数量</a></h3><p>这道题相比毯子那题，就是给每个点位加了一个权重，我们还能只固定右端点计算么？答案是不对的，看下面这种case：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/43120613/1736076590724-134feb90-ac7d-4847-9791-7602326e244d.png"></p>
<p>这种情况明显是固定左端点最优，所以这一题我们可以比较下使用左端点和使用右端点分别得到的答案，取一个最大值即可。</p>
<p><strong>如何在使用左端点的情况下也可以复用之前的函数？</strong></p>
<p>将每个区间按照原点做一个对称数组， 例如[1,5] 变成[-5, -1], 这样按照[1,5]的左端点就变成了按照[-5,-1]的右端点了，完成代码复用！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maximumCoins</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; coins, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="built_in">maximumWhiteTiles</span>(coins, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item : coins)&#123;</span><br><span class="line">        <span class="type">int</span> temp = item[<span class="number">0</span>];</span><br><span class="line">        item[<span class="number">0</span>] = - item[<span class="number">1</span>];</span><br><span class="line">        item[<span class="number">1</span>] = -temp;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, <span class="built_in">maximumWhiteTiles</span>(coins, k));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找出最长等值子数组"><a href="#找出最长等值子数组" class="headerlink" title="找出最长等值子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-longest-equal-subarray/description/">找出最长等值子数组</a></h3><p>看了两个提示之后才有了正确的思路，哎，任重道远啊！</p>
<p>关键技巧：<strong>分组滑动窗口</strong></p>
<p>等值子数组的关键性质就是，子数组中的所有元素都相等，那我们将所有的元素按值分组，分完组后，就可以只关注下标了，两个下标如过间隔相差大于1，那么之间的元素一定是需要删除的，这就有了消耗，我们一直向后滑，如过需要删除的元素大于k，我们就需要舍弃前面的元素，让滑动窗口内的消耗一直小于等于k。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp;[_, v] : h)&#123;</span><br><span class="line">    <span class="type">int</span> m = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(m &lt;= ans) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> left&#123;<span class="number">0</span>&#125;, len&#123;<span class="number">1</span>&#125;, last&#123;v[<span class="number">0</span>]&#125;, need_del&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">1</span>; right &lt; m; ++right)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        <span class="keyword">if</span>(v[right] - last &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            need_del += v[right] - last - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(need_del &gt; k)&#123;</span><br><span class="line">            <span class="type">int</span> second = left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(second == right)&#123;</span><br><span class="line">                left = right;</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">                need_del -= (v[right] - last - <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                need_del -= (v[second] - v[left] - <span class="number">1</span>);</span><br><span class="line">                len--;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = v[right];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在做了这些题之后，可以发现不定长滑动窗口题的一些共通点：</p>
<ul>
<li>往往是一个数组</li>
<li>往往是让我们找满足某个条件的最大&#x2F;最小子数组&#x2F;子串，就算不是，可能也需要间接转成这些问题</li>
<li>还需要多做一些题。。。。</li>
</ul>
<h3 id="删除最短的子数组使剩余数组有序"><a href="#删除最短的子数组使剩余数组有序" class="headerlink" title="删除最短的子数组使剩余数组有序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description/">删除最短的子数组使剩余数组有序</a></h3><p>TODO</p>
<p>暂时没有思路</p>
<h3 id="替换子串得到平衡字符串"><a href="#替换子串得到平衡字符串" class="headerlink" title="替换子串得到平衡字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/description/">替换子串得到平衡字符串</a></h3><p>根据题意，容易看出我们的窗口就是待替换子串，因为我们可以将它替换成长度相同的任意字符串，所以我们只要保证窗口外的QWER的个数全部不大于n&#x2F;4(如果有某个字符的数量超过n&#x2F;4， 1是不符合题意，2是他多出来的部分无法替换，没有贡献)</p>
<ul>
<li>right进入窗口</li>
<li>当前是否满足条件，如果满足条件，尝试左移left，更新答案</li>
</ul>
<p>只有两步的原因是，我们的循环内部是满足条件的，所以可以更新答案，舍去第三步</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right)&#123;</span><br><span class="line">    cnt[s[right]] --;</span><br><span class="line">    <span class="keyword">while</span>(cnt[<span class="string">&#x27;Q&#x27;</span>] &lt;= n/<span class="number">4</span> &amp;&amp; cnt[<span class="string">&#x27;W&#x27;</span>] &lt;= n/<span class="number">4</span> &amp;&amp; cnt[<span class="string">&#x27;E&#x27;</span>] &lt;= n/<span class="number">4</span> &amp;&amp; cnt[<span class="string">&#x27;R&#x27;</span>] &lt;= n/<span class="number">4</span>)&#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        cnt[s[left++]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1358-包含所有三种字符的子字符串数目"><a href="#1358-包含所有三种字符的子字符串数目" class="headerlink" title="1358. 包含所有三种字符的子字符串数目"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/">1358. 包含所有三种字符的子字符串数目</a></h3><p>这一题是一个新的类型，求子数组数量，这类问题一般考虑 ans +&#x3D; left.</p>
<p>以此题为例，要求我们求出abc三个字符都至少出现一次的子字符串，我们考虑一个满足条件最小的答案-每个字符只出现过一次！所以我们的窗口就是abc都至少出现过一次，如果right进来之后不满足条件，我们就尝试左移left，一旦跳出循环，我们让答案增加left个（为什么是left个，因为left++之后跳出while，当前left-right是不满足条件的，left-1到right才是满足条件的子串，但是考虑个数的话，要加上下标为0的那个子串）一句话总结，如果left不为0，那么一定是满足了子串的条件导致left左移！！！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans&#123;<span class="number">0</span>&#125;, left&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">3</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right)&#123;</span><br><span class="line">    cnt[s[right]-<span class="string">&#x27;a&#x27;</span>]++;                              <span class="comment">//right进来</span></span><br><span class="line">    <span class="keyword">while</span>(cnt[<span class="number">0</span>] &gt;= <span class="number">1</span> &amp;&amp; cnt[<span class="number">1</span>] &gt;= <span class="number">1</span> &amp;&amp; cnt[<span class="number">2</span>] &gt;= <span class="number">1</span>)&#123; <span class="comment">//如果满足条件了</span></span><br><span class="line">        cnt[s[left++]-<span class="string">&#x27;a&#x27;</span>]--;                         <span class="comment">//左移left</span></span><br><span class="line">    &#125; </span><br><span class="line">    ans += left;                                      <span class="comment">//当前left不为0的话，一定是满足了while的条件导致移动了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2962-统计最大元素出现至少-K-次的子数组"><a href="#2962-统计最大元素出现至少-K-次的子数组" class="headerlink" title="2962. 统计最大元素出现至少 K 次的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/description/">2962. 统计最大元素出现至少 K 次的子数组</a></h3><p>与上面一题类似，条件是窗口内的最大元素至少出现k次，代码类似<br>好好理解为什么ans+&#x3D;left是对的</p>
<p>其实这个答案更新的过程我觉得可以将left理解成移动的次数，for example， nums &#x3D; [3, 3], k &#x3D; 1, ans&#x3D;3:<br>1.right &#x3D; 0, cnt &#x3D; 1, 满足条件， left &#x3D; 1， exit loop， ans +&#x3D; 1</p>
<p>2.right &#x3D; 1, cnt &#x3D; 1, 满足条件， left &#x3D; 2， exit loop， ans +&#x3D; 2</p>
<p>进入循环，left加1，表示0-left的所以下标都可以与right组合成答案，left移动的次数就是当前子串的数量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> ans&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> mx = *<span class="built_in">max_element</span>(<span class="built_in">begin</span>(nums), <span class="built_in">end</span>(nums));</span><br><span class="line"><span class="type">int</span> left&#123;<span class="number">0</span>&#125;, cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right)&#123;</span><br><span class="line">    <span class="keyword">if</span>(mx == nums[right]) cnt ++;</span><br><span class="line">    <span class="keyword">while</span>(cnt &gt;=k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left++] == mx)&#123;</span><br><span class="line">            --cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



<h3 id="3325-字符至少出现-K-次的子字符串-I"><a href="#3325-字符至少出现-K-次的子字符串-I" class="headerlink" title="3325. 字符至少出现 K 次的子字符串 I"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-substrings-with-k-frequency-characters-i/description/">3325. 字符至少出现 K 次的子字符串 I</a></h3><p>求子数组个数问题，因为只有小写字母，所以我们可以用数组来记录每个元素出现的次数，窗口内的条件就是某个字符出现的次数大于等于k个，答案的更新和上面一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt[<span class="number">26</span>]&#123;<span class="number">0</span>&#125;, left&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> check = [&amp;cnt, k]()-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">26</span>; ++i)&#123;</span><br><span class="line">       <span class="keyword">if</span>(cnt[i] &gt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right)&#123;</span><br><span class="line">   cnt[s[right]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">check</span>())&#123;</span><br><span class="line">       cnt[s[left++]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">   &#125;</span><br><span class="line">   ans += left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2799-统计完全子数组的数目"><a href="#2799-统计完全子数组的数目" class="headerlink" title="2799. 统计完全子数组的数目"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-subarrays-in-an-array/description/">2799. 统计完全子数组的数目</a></h3><p>求子数组个数问题，先求不同元素数目，然后窗口内的条件就是元素出现的次数要大于等于整个数组不同元素数目，答案更新和上面一致。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; h;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right)&#123;</span><br><span class="line">    h[nums[right]] ++;</span><br><span class="line">    <span class="keyword">while</span>(h.<span class="built_in">size</span>() &gt;= k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(--h[nums[left]] == <span class="number">0</span>)&#123;</span><br><span class="line">            h.<span class="built_in">erase</span>(nums[left]);</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



<h3 id="2537-统计好子数组的数目"><a href="#2537-统计好子数组的数目" class="headerlink" title="2537. 统计好子数组的数目"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-the-number-of-good-subarrays/">2537. 统计好子数组的数目</a></h3><p>求子数组个数问题，这道题窗口的条件判断类似上面的题，唯一需要注意的是更新维护的值，在注释中解释：</p>
<p><em>注释掉的代码是我的第一版，比较繁琐，其实主要考虑是当前这个元素的影响在最后再加到窗口中</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left&#123;<span class="number">0</span>&#125;, cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; h;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right)&#123;</span><br><span class="line">            cnt += h[nums[right]]++;</span><br><span class="line">            <span class="keyword">while</span>(cnt &gt;= k)&#123;</span><br><span class="line">                <span class="comment">// if(nums[left] == nums[right])&#123;</span></span><br><span class="line">                <span class="comment">//     cnt -= h[nums[left]];</span></span><br><span class="line">                <span class="comment">// &#125;else&#123;</span></span><br><span class="line">                <span class="comment">//     if(h[nums[left]] &gt; 1) cnt -= h[nums[left]] - 1;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">// h[nums[left++]]--;</span></span><br><span class="line">                cnt -= --h[nums[left++]];  <span class="comment">//111...1, 删掉第一个1的影响是少了4-1个下标对</span></span><br><span class="line">                <span class="comment">//left++;</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans += left;</span><br><span class="line">            <span class="comment">//h[nums[right]]++;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



<h3 id="713-乘积小于-K-的子数组"><a href="#713-乘积小于-K-的子数组" class="headerlink" title="713. 乘积小于 K 的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-product-less-than-k/description/">713. 乘积小于 K 的子数组</a></h3><p>此题属于求子数组个数问题中的越短越合法，考虑当前新增元素right，如果窗口[left, right]复合条件的话，那么会新增多少个答案？[left…right], [left+1, ….right], ….., [right] 一共right - left + 1个。</p>
<p>注意题目数据范围，k不大于1的时候答案一定是0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(k &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> t&#123;<span class="number">1</span>&#125;, left&#123;<span class="number">0</span>&#125;, ans&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right)&#123;</span><br><span class="line">    t *= nums[right];</span><br><span class="line">    <span class="keyword">while</span>(t &gt;= k)&#123;</span><br><span class="line">        t /= nums[left++];</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (right - left + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



<h3 id="2302-统计得分小于-K-的子数组数目"><a href="#2302-统计得分小于-K-的子数组数目" class="headerlink" title="2302. 统计得分小于 K 的子数组数目"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/">2302. 统计得分小于 K 的子数组数目</a></h3><p>和上道题一样，只不过窗口的条件计算不一样</p>
<p>01月14日Thinking: 滑动窗口一定基于一个连续的性质？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> ans&#123;<span class="number">0</span>&#125;, score&#123;<span class="number">0</span>&#125;, sum&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> left&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right)&#123;</span><br><span class="line">    sum += nums[right];</span><br><span class="line">    score = sum * (right - left + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(score &gt;= k)&#123;</span><br><span class="line">        sum -= nums[left++];</span><br><span class="line">        score = sum * (right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (right - left + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



<h3 id="2762-不间断子数组"><a href="#2762-不间断子数组" class="headerlink" title="2762. 不间断子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/continuous-subarrays/description/">2762. 不间断子数组</a></h3><p>求子数组问题，这题的关键在于怎么判断当前新加的元素是否满足条件，容易看出，只要之前的窗口中最小值和最大值与当前元素的差的绝对值小于等于2，就满足条件，那么是不是只需要维护最小值和最大值就可以了呢？显然不是，一旦最小值滑出去了，怎么快速地知道新的最小值呢，所以我们这里可以借用map，它的所有键都是排序的，这样就能快速找到最小值最大值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left&#123;<span class="number">0</span>&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right)&#123;</span><br><span class="line">    mp[nums[right]]++;</span><br><span class="line">    <span class="keyword">while</span>(!mp.<span class="built_in">empty</span>() &amp;&amp; (<span class="built_in">abs</span>(mp.<span class="built_in">begin</span>()-&gt;first-nums[right]) &gt; <span class="number">2</span></span><br><span class="line">    || <span class="built_in">abs</span>(mp.<span class="built_in">rbegin</span>()-&gt;first-nums[right]) &gt; <span class="number">2</span>))&#123;</span><br><span class="line">        <span class="type">int</span> t = nums[left];</span><br><span class="line">        <span class="keyword">if</span>(--mp[t] == <span class="number">0</span>)&#123;</span><br><span class="line">            mp.<span class="built_in">erase</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        ++left;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += right - left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



<h3 id="930-和相同的二元子数组-560-和为-K-的子数组-（560不能使用滑动窗口！！）"><a href="#930-和相同的二元子数组-560-和为-K-的子数组-（560不能使用滑动窗口！！）" class="headerlink" title="930. 和相同的二元子数组 &#x3D; 560. 和为 K 的子数组 （560不能使用滑动窗口！！）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-subarrays-with-sum/description/">930. 和相同的二元子数组</a> &#x3D; <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">560. 和为 K 的子数组</a> （560不能使用滑动窗口！！）</h3><p>恰好型滑动窗口解法：</p>
<blockquote>
<p>例如，要计算有多少个元素和恰好等于 k 的子数组，可以把问题变成：</p>
<p>计算有多少个元素和 ≥𝑘 的子数组。<br>计算有多少个元素和 ＞𝑘 的子数组，也就是 ≥𝑘+1 的子数组。答案就是元素和 ≥𝑘 的子数组个数，减去元素和 ≥𝑘+1的子数组个数。这里把 ＞转换成 ≥，从而可以把滑窗逻辑封装成一个函数 f，然后用 f(k) - f(k + 1) 计算，无需编写两份滑窗代码。</p>
<p>总结：「恰好」可以拆分成两个「至少」，也就是两个「越长越合法」的滑窗问题。</p>
<p>注：也可以把问题变成 ≤𝑘 减去 ≤ 𝑘−1（两个至多）。可根据题目选择合适的变形方式。</p>
</blockquote>
<p>具体到这一题，是非常贴切上面的描述的，cnt1是大于等于goal的个数，cnt2是大于等于goal+1的个数即大于k的个数（因为数组元素都是整数），cnt2是cnt1的真子集，其补集就是等于goal的个数！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans&#123;<span class="number">0</span>&#125;, sum1&#123;<span class="number">0</span>&#125;, sum2&#123;<span class="number">0</span>&#125;, left1&#123;<span class="number">0</span>&#125;, left2&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> cnt1&#123;<span class="number">0</span>&#125;, cnt2&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); ++right)&#123;</span><br><span class="line">    sum1 += nums[right];</span><br><span class="line">    sum2 += nums[right];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&gt;=</span></span><br><span class="line">    <span class="keyword">while</span>(left1 &lt;= right &amp;&amp; sum1 &gt;= goal)&#123;</span><br><span class="line">        sum1 -= nums[left1++];</span><br><span class="line">        cnt1 ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left2 &lt;= right &amp;&amp; sum2 &gt;= goal + <span class="number">1</span>)&#123;</span><br><span class="line">        sum2 -= nums[left2++];</span><br><span class="line">        cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (cnt1 - cnt2);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; right &lt;&lt;&quot; &quot; &lt;&lt; cnt1 &lt;&lt;&quot; &quot; &lt;&lt; cnt2 &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



<p><strong>为什么560不能使用滑动窗口？</strong></p>
<p>因为这一题的子数组和不能保证非递减的，那我们移除left的元素造成的影响就是不确定的？具体一点的例子就是[-1, -1, 1, 1], k &#x3D; 0, 数组加完都不满足条件， 如果是[0, 0, 1] 甚至是[-1, 0, 1], 我们不断地排除left一定会让窗口的也会慢慢变小(思考一下这里！！）</p>
<h1 id="c-常用数据结构"><a href="#c-常用数据结构" class="headerlink" title="c.常用数据结构"></a>c.常用数据结构</h1><p>(前缀和&#x2F;差分&#x2F;栈&#x2F;队列&#x2F;堆&#x2F;字典树&#x2F;并查集&#x2F;树状数组&#x2F;线段树)</p>
<h2 id="0-技巧-枚举右，维护左"><a href="#0-技巧-枚举右，维护左" class="headerlink" title="0.技巧-枚举右，维护左"></a>0.技巧-枚举右，维护左</h2><p>对于双变量问题，例如求两数之和a+b&#x3D;c，我们可以枚举b，转换成单变量问题，也就是在b左边查找是否含有c-b，而这可以用哈希表维护，这个技巧称之为枚举右，维护左。</p>
<p>来几个例题感受下思想：</p>
<h3 id="1814-统计一个数组中好对子的数目"><a href="#1814-统计一个数组中好对子的数目" class="headerlink" title="1814. 统计一个数组中好对子的数目"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-nice-pairs-in-an-array/description/">1814. 统计一个数组中好对子的数目</a></h3><p>要求</p>
<ul>
<li><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])&lt;/font&gt;</code></li>
</ul>
<p><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">交换一下，即nums[i] -rev(nums[i] &#x3D;&#x3D; nums[j] - rev(nums[j])</font></p>
<p>那我们只需要枚举元素nums[i]，在枚举的同时在哈希中记录下nums[i]-rev(nums[i])</p>
<p>记录之前，先看看哈希中有没有这个值，有几个就代表之前出现了几次与当前元素凑成对子的数字，累加到答案中即可。这就是枚举右，维护左！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; h;</span><br><span class="line"><span class="type">int</span> ans&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">    string tmp = <span class="built_in">to_string</span>(nums[i]);  <span class="comment">//枚举右</span></span><br><span class="line">    <span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> rev = <span class="built_in">stoi</span>(tmp);</span><br><span class="line">    ans = (ans + h[nums[i] - rev])%mod;</span><br><span class="line">    h[nums[i] -rev]++;   <span class="comment">//维护左</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>

<h3 id="1031-两个非重叠子数组的最大和"><a href="#1031-两个非重叠子数组的最大和" class="headerlink" title="1031. 两个非重叠子数组的最大和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/description/">1031. 两个非重叠子数组的最大和</a></h3><p>这题和上面那一题不对，要求求两个非重叠子数组元素的最大和。</p>
<p>首先，我们可以求前缀和，那么每个元素为开始&#x2F;结尾且长度为firstLen或者secondLen的子数组和我们都能O(1)的求出来。既然如此，我们尝试枚举某个元素，我可以当即知道这个元素为start且长度为firstLen或secondLen的子数组之和，我肯定想知道前面的元素中最大的长度为firstLen&#x2F;secondLen的子数组和，这就是维护左，我们可以用一个变量记录下出现过的长度为firstLen或者secondLen的子数组和，尝试更新答案即可。</p>
<p>我的代码中是这样 0…..i-1  , i …   记录每个元素为结尾的长度为firstLen和secondLen的子数组和，然后在遍历的过程中维护左。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p_fi</span><span class="params">(n<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p_se</span><span class="params">(n<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; ++i) &#123; </span><br><span class="line">    pre[i] = pre[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= firstLen) p_fi[i] = pre[i] - pre[i-firstLen];</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= secondLen) p_se[i] = pre[i] - pre[i-secondLen];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans&#123;<span class="number">0</span>&#125;, mx_f&#123;<span class="number">0</span>&#125;, mx_s&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">min</span>(firstLen, secondLen); i&lt;=n; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; firstLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+secondLen<span class="number">-1</span> &lt;= n) ans = <span class="built_in">max</span>(ans, mx_f + pre[i+secondLen<span class="number">-1</span>] - pre[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; secondLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+firstLen<span class="number">-1</span> &lt;= n) ans = <span class="built_in">max</span>(ans, mx_s + pre[i+firstLen<span class="number">-1</span>] - pre[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= firstLen) mx_f = <span class="built_in">max</span>(mx_f, p_fi[i]);</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= secondLen) mx_s = <span class="built_in">max</span>(mx_s, p_se[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



<h3 id="1930-长度为-3-的不同回文子序列"><a href="#1930-长度为-3-的不同回文子序列" class="headerlink" title="1930. 长度为 3 的不同回文子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/description/">1930. 长度为 3 的不同回文子序列</a></h3><p>本题不同于上面两题，是三个变量，枚举中间变量比较好处理。</p>
<p>前后可以分别用前缀和及后缀和来维护，来看第一种写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">p</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;<span class="number">26</span>; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == s[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>) p[i][j] = p[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> p[i][j] = p[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, <span class="type">bool</span>&gt; h;</span><br><span class="line"><span class="type">int</span> ans&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i&lt;=n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;<span class="number">26</span>; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i<span class="number">-1</span>][j] &amp;&amp; (p[n][j]-p[i][j]) &amp;&amp; !h[&#123;s[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>, j&#125;])&#123;</span><br><span class="line">            h[&#123;s[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>, j&#125;] = <span class="literal">true</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>

<p>看看如何优化：</p>
<p>首先空间上，是不是一定需要二维数组？</p>
<p>不是，前缀和我们可以维护左的思想来做，那么后缀和呢，是不是先算一遍前缀和，然后把当前已经遍历过的元素减掉就可以了，所以一维数组就可以，如此，时间上也少了一层循环！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>, <span class="title">suf</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">    ++suf[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, <span class="type">bool</span>&gt; h;</span><br><span class="line"><span class="type">int</span> ans&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">    ++pre[s[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    --suf[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;<span class="number">26</span>; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[j] &amp;&amp; suf[j] &amp;&amp; !h[&#123;s[i]-<span class="string">&#x27;a&#x27;</span>, j&#125;])&#123;</span><br><span class="line">            h[&#123;s[i]-<span class="string">&#x27;a&#x27;</span>, j&#125;] = <span class="literal">true</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



<p>进一步优化，这个map可以优化成一个常数上的查询，我们使用一个26*26的二维数组即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>, <span class="title">suf</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">    ++suf[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> h[<span class="number">26</span>][<span class="number">26</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">    ++pre[s[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    --suf[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;<span class="number">26</span>; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[j] &amp;&amp; suf[j] &amp;&amp; !h[s[i]-<span class="string">&#x27;a&#x27;</span>][j])&#123;</span><br><span class="line">            h[s[i]-<span class="string">&#x27;a&#x27;</span>][j] = <span class="literal">true</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



<h3 id="2874-有序三元组中的最大值-II"><a href="#2874-有序三元组中的最大值-II" class="headerlink" title="2874. 有序三元组中的最大值 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/description/">2874. 有序三元组中的最大值 II</a></h3><p>本题是三元组(i, j, k), 要求(nums[i] - nums[j] ) * nums[k]的最大值</p>
<ul>
<li>1.我们可以枚举j，这要维护前缀最大值和后缀最大值即可， 时间复杂度和空间复杂度都是O(n)</li>
<li>2.我们可以枚举k，那么只要维护nums[i]-nums[j]的最大值即可， 参考<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121. 买卖股票的最佳时机</a>，维护前面的最大值mx和前面的最大利润，然后枚举k计算更新ans</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> ans&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> mx &#123;<span class="number">0</span>&#125;, i_minus_j&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans,  i_minus_j * <span class="number">1LL</span> * nums[i]);</span><br><span class="line">    i_minus_j = <span class="built_in">max</span>(i_minus_j, mx - nums[i]);</span><br><span class="line">    mx = <span class="built_in">max</span>(mx, nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1-前缀和"><a href="#1-前缀和" class="headerlink" title="1.前缀和"></a>1.前缀和</h2><p>s[i] &#x3D; s[i-1] + cur[i];</p>
<p>s[0] &#x3D; 0;</p>
<p>如此，计算子数组和我们就可以O(1)的方式计算出，相当于空间换时间。</p>
<h3 id="2055-蜡烛之间的盘子"><a href="#2055-蜡烛之间的盘子" class="headerlink" title="2055. 蜡烛之间的盘子"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/plates-between-candles/description/">2055. 蜡烛之间的盘子</a></h3><p>题意太长，跳转link查看原题。</p>
<p>给出了一个区间的左右端点，我们可以利用只记录盘子的前缀和来计算出数量，但是问题就是左右端点可能不一定满足条件，容易看出，只要找出区间内最靠近左端点和右端点的蜡烛，我们就能得到正确的答案！</p>
<ul>
<li>方法一：利用二分，我们可以将蜡烛的下表放在一个数组里，然后对于query的左右端点，分别找到最近的蜡烛，就可以找到答案</li>
</ul>
<p>空间复杂度：O(N)</p>
<p>时间复杂度：O(NlogN)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">platesBetweenCandles</span><span class="params">(string s, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n<span class="number">+1</span>, <span class="number">0</span>)</span>, idx</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            pre[i<span class="number">+1</span>] = pre[i] + (s[i] == <span class="string">&#x27;*&#x27;</span> ? <span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">                idx.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(queries.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> no&#123;<span class="number">0</span>&#125;, m = idx.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; q : queries)&#123;</span><br><span class="line">            <span class="type">int</span> l = q[<span class="number">0</span>], r = q[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> lit = <span class="built_in">lower_bound</span>(<span class="built_in">begin</span>(idx), <span class="built_in">end</span>(idx), l) - <span class="built_in">begin</span>(idx);</span><br><span class="line">            <span class="keyword">auto</span> rit = <span class="built_in">upper_bound</span>(<span class="built_in">begin</span>(idx), <span class="built_in">end</span>(idx), r) - <span class="built_in">begin</span>(idx) - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; idx[lit] &lt;&lt;&quot; &quot; &lt;&lt; idx[rit] &lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>((lit &gt;=<span class="number">0</span> &amp;&amp; lit &lt; m &amp;&amp; rit &gt;=<span class="number">0</span> &amp;&amp; rit &lt; m) &amp;&amp; idx[lit] &gt;= l &amp;&amp; idx[lit] &lt;= r &amp;&amp; idx[rit] &gt;= l &amp;&amp; idx[rit] &lt;= r)&#123;</span><br><span class="line">                ans[no++] = pre[idx[rit]<span class="number">+1</span>] - pre[idx[lit]];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[no++] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们维护每个盘子最近的蜡烛就可以了，左边最近的和右边最近的(左端点左边的蜡烛如果不满足条件，就使用右边的蜡烛！</li>
</ul>
<p>空间复杂度: O(N)</p>
<p>时间复杂度：O(N)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">platesBetweenCandles</span><span class="params">(string s, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n<span class="number">+1</span>, <span class="number">0</span>)</span>, <span class="title">left</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> l&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            pre[i<span class="number">+1</span>] = pre[i] + (s[i] == <span class="string">&#x27;*&#x27;</span> ? <span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">                l = i;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> r&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">                r = i;</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(queries.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> no&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; q : queries)&#123;</span><br><span class="line">            l = q[<span class="number">0</span>], r = q[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> left_p = left[l];</span><br><span class="line">            <span class="keyword">if</span>(left_p &lt; l) left_p = right[l];</span><br><span class="line">            <span class="type">int</span> right_p = left[r];</span><br><span class="line">            <span class="keyword">if</span>(left_p &lt;= right_p &amp;&amp; left_p != <span class="number">-1</span>)&#123;</span><br><span class="line">                ans[no++] = pre[right_p<span class="number">+1</span>] - pre[left_p];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[no++] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>提交后发现，对于vector，我们使用[]运算符和at所有的时间是不一样的，应该是at多了下标检查这一步所以花费了一些时间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">     reference</span><br><span class="line">     <span class="keyword">operator</span>[](size_type __n) _GLIBCXX_NOEXCEPT</span><br><span class="line">     &#123; <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_M_impl._M_start + __n); &#125;</span><br><span class="line"></span><br><span class="line">     const_reference</span><br><span class="line">     <span class="keyword">operator</span>[](size_type __n) <span class="type">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">     &#123; <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_M_impl._M_start + __n); &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">     <span class="comment">/// Safety check used only from at().</span></span><br><span class="line">     <span class="type">void</span></span><br><span class="line">     _M_range_check(size_type __n) <span class="type">const</span></span><br><span class="line">     &#123;</span><br><span class="line"><span class="keyword">if</span> (__n &gt;= <span class="keyword">this</span>-&gt;<span class="built_in">size</span>())</span><br><span class="line">  __throw_out_of_range_fmt(__N(<span class="string">&quot;vector::_M_range_check: __n &quot;</span></span><br><span class="line">			       <span class="string">&quot;(which is %zu) &gt;= this-&gt;size() &quot;</span></span><br><span class="line">			       <span class="string">&quot;(which is %zu)&quot;</span>),</span><br><span class="line">			   __n, <span class="keyword">this</span>-&gt;<span class="built_in">size</span>());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *  @brief  Provides access to the data contained in the %vector.</span></span><br><span class="line"><span class="comment">      *  @param __n The index of the element for which data should be</span></span><br><span class="line"><span class="comment">      *  accessed.</span></span><br><span class="line"><span class="comment">      *  @return  Read/write reference to data.</span></span><br><span class="line"><span class="comment">      *  @throw  std::out_of_range  If @a __n is an invalid index.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *  This function provides for safer data access.  The parameter</span></span><br><span class="line"><span class="comment">      *  is first checked that it is in the range of the vector.  The</span></span><br><span class="line"><span class="comment">      *  function throws out_of_range if the check fails.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function">reference</span></span><br><span class="line"><span class="function">     <span class="title">at</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">_M_range_check(__n);</span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">this</span>)[__n]; </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>





<h3 id="930-和相同的二元子数组-560-和为-K-的子数组"><a href="#930-和相同的二元子数组-560-和为-K-的子数组" class="headerlink" title="930. 和相同的二元子数组 &#x3D; 560. 和为 K 的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-subarrays-with-sum/description/">930. 和相同的二元子数组</a> &#x3D; <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">560. 和为 K 的子数组</a></h3><p>这两道题几乎完全一样，因为所有的子数组和都可以通过前缀和求出来。所以我们可以利用哈希表记录所有的前缀和，然后遍历，遍历的时候发现所以当前前缀和sum减去我们的goal有在哈希表中出现的话，就有了构成和为k的子数组，我们累加到答案中即可。</p>
<p>时间复杂度：O(NlogN)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans&#123;<span class="number">0</span>&#125;, pre&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; h;</span><br><span class="line">    h[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">        pre += x;</span><br><span class="line">        ans += h[pre - k];</span><br><span class="line">        h[pre]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这道题其实可以通过滑动窗口来求解，恰好型滑动窗口，更新在不定长滑动窗口一节中</p>
<h3 id="1524-和为奇数的子数组数目"><a href="#1524-和为奇数的子数组数目" class="headerlink" title="1524. 和为奇数的子数组数目"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/">1524. 和为奇数的子数组数目</a></h3><p>子数组的和可以由两个前缀和相减得到，我们维护两个变量，一个记录奇数前缀和的个数，一个记录偶数前缀和的个数，分情况更新答案即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> odd&#123;<span class="number">0</span>&#125;, even&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">        <span class="type">int</span> sum &#123;<span class="number">0</span>&#125;, ans&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                ans = (ans + even) % mod;</span><br><span class="line">                ++ odd;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = (ans + odd) % mod;</span><br><span class="line">                ++ even;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="3026-最大好子数组和"><a href="#3026-最大好子数组和" class="headerlink" title="3026. 最大好子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-good-subarray-sum/">3026. 最大好子数组和</a></h3><p>给你一个长度为 n 的数组 nums 和一个 正 整数 k 。<br>如果 nums 的一个子数组中，第一个元素和最后一个元素 差的绝对值恰好 为 k ，我们称这个子数组为 好 的。换句话说，如果子数组 nums[i..j] 满足 |nums[i] - nums[j]| &#x3D;&#x3D; k ，那么它是一个好子数组。<br>请你返回 nums 中 好 子数组的 最大 和，如果没有好子数组，返回 0 </p>
<p>i…j…k</p>
<p>假如（i, k）和（j, k）都满足条件，我们取max( sum(i…k), sum(j…k))</p>
<p>而子数组和可以通过前缀和求出，所以我们维护i和j的前缀和，容易看出来，维护最小的有意义，因为prek确定，sumi或者sumj越小，答案越大，我们用一个map存储下每个val对应的最小的前缀和即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maximumSubarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans&#123;LLONG_MIN&#125;, sum&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt; h;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="keyword">if</span>(h.<span class="built_in">count</span>(i + k))&#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, sum - h[i + k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(h.<span class="built_in">count</span>(i - k))&#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, sum - h[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!h.<span class="built_in">count</span>(i))&#123;</span><br><span class="line">                h[i] = sum - i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                h[i] = <span class="built_in">min</span>(h[i], sum - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == LLONG_MIN ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2025/05/19/Leetcode-0x3f%E9%A2%98%E5%8D%95/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">算法和数据结构</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2025/05/19/Leetcode-hot-100/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Leetcode-hot-100</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2025
        <i class="ri-heart-fill heart_icon"></i> Xudong0722
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="MoonLight"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://zxd-sbq.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>